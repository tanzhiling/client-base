### 数据结构

#### 栈
>一种遵循从先进后出LIFO/Last In First Out原则的有序集合 新添加的或待删除的元素都保存在栈的同一端 称作栈顶 另一端为栈底 在栈里 新元素都靠近栈顶 就元素都接近栈顶

栈的实现 stack.js 
1. push添加一个或几个新元素到栈顶
2. pop溢出栈顶元素 同时返回被移除的元素
3. peek返回栈顶元素 不对栈做修改 
4. isEmpty栈内无元素返回ture 否则返回false
5. size返回栈内元素个数
6. clear清空栈

栈的应用
1. 十进制转任意进制
2. 逆波兰表达式计算
3. 实现有min方法的栈

#### 队列 
>一种遵循先进先出FIFO/First In First Out原则 队列在尾部添加新元素 并从头部移除元素 最新添加的元素必须排在队列的末尾

队列的实现 queue.js
1. enqueue 向队列尾部添加一个或多个元素
2. dequeue 移除队列的第一项
3. head 返回队列的第一个元素 队列不做任何变动
4. tail 返回队列的最后一个元素 队列不做任何变动
5. isEmpty 队列无元素返回true 否则返回false
6. size 返回队列元素个数
7. clear 清空队列

队列的应用
1. 约瑟夫环
2. 斐波那契数列
3. 队列实现一个栈

#### 优先队列
>元素添加移除 可通过参数进行优先级控制 

#### 循环队列
>生成一个闭环空间

#### 链表
>存储有序的元素的集合 不同于数据 链表中的元素在内存中并不是连续位置的 每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（指针/链接）组成 

单向链表
1. 用一组任意的内存空间去存储数据元素
2. 每个节点node都由数据本身和一个指向后续节点的指针组成
3. 整个链表的存取必须从头指针开始 头指针指向第一个节点
4. 最后一个节点的指针指向空null

循环链表 
单向链表中的最后一个节点的指针指向首节点

双向链表
创建节点 并生成一个指向前一个节点的指针 以及指向后一个节点的指针 还有节点数据

链表的主要操作
1. 创建节点
2. 向后追加节点
3. 插入指定位置节点
4. 查找前置节点
5. 搜索/遍历节点
6. 修改节点
7. 删除节点
8. 打印节点

>总结 链表相对于数组最大的优点 无需移动链表中的元素 就可以实现元素的添加和删除 因此当需要添加和删除很多元素时 最好的选择是链表而非数组

#### 集合
> 集合是由一组无序且唯一的项组成的 例如Set

#### 哈希表
>在计算中 一个哈希表hashTable或hashMap 是一种实现关联数组的抽象数据类型 该结构可以将键映射到值
>哈希表使用哈希函数/散列函数来计算一个值在数组或桶(buckets)或槽(slots)中对应的索引 可使用该索引找到所需的值
>理想情况下 散列函数将为每个键分配一个唯一的桶 但是大多数哈希表设计采用不完美的散列函数 这可能导致哈希冲突 也就是散列函数为多个键生成了相同的索引 这种碰撞必须以某种方式进行处理
>解决冲突：分离链接、线性探查和双散列法
常见的散列函数 'lose lose'散列函数 方法是简单地将每个键值中的每个字母的ASCII值相加

#### 树
> 树是一种非顺序数据机构 一种分层数据的抽象模型 对于存储需要快速查找的数据非常有用
树包含以下几种属性
1. 节点
    + 根节点
    + 内部节点：非根节点 且有子节点的节点
    + 外部节点：无子节点的节点
2. 子树
3. 深度 节点到根节点的节点数量
4. 高度 树的高度取决于所有节点深度中的最大值
5. 层级 按照节点层级来分层 
 
>实现一个二叉搜索树 二叉搜索树的每个父节点的键值要大于左边子节点小于右边子节点
实现步骤
1. constructor() 初始话
2. insert(value) 二叉树中查找一个节点 如果存在返回true 否则返回false
3. preOrderTraverse(cb) 先序遍历
4. inOrderTraverse(cb) 中序遍历
5. postOrderTraverse(cb) 后序遍历
6. minNodeValue() 最小节点值
7. maxNodeValue() 最大节点值
8. removeNode(value) 移除节点
9. destory() 销毁树
